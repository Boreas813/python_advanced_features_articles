# 理解Python web中的异步

[原文链接](https://www.b-list.org/weblog/2022/aug/16/async/)

最近[Django4.1发布](https://www.djangoproject.com/weblog/2022/aug/03/django-41-released/)，似乎人们最关注的是扩展了对异步的支持，与此同时，在过去的几年里，Python的web生态系统作为一个整体不断涌现出完全异步或从一开始就支持完全异步的新框架。

随之引出了许多问题例如：什么是异步Python？为什么人们这么在乎它？它对构建web应用真的那么重要？这些新的框架和工具到底是什么东西？

所以让我们深入研究。如果你已经理解Pyhton异步编程，或有其它语言的异步实践，接下来的一些章节可能会对你有所帮助，所以你可以随便看看Python web世界中异步的实际摘要，尽管有一些Python特定的部分可能仍然是有用的。

## 考虑一个函数

下面是一个函数用来解决人尽皆知的一个讨厌问题：
```python
def fizzbuzz(n):
    result = ""
    if not n % 3:
        result += "Fizz"
    if not n % 5:
        result += "Buzz"
    return result or n
```

现在假设我们调用：`fizzubzz(12)`。Python会如何执行这个函数？

想象一个箭头指向正在执行的代码行；它从外面某处开始，然后一个东西调用了`fizzubzz(12)`箭头跳到了函数内的第一行。然后它一行一行执行，直到运行到最后的`return`陈述，这时箭头条回到调用`fizzbuzz`的函数。

我们还可以想象更复杂的函数：比如一个函数中有一个循环，它的箭头可能会一遍又一遍地跳回到循环的起点，直到它最终退出，而一个调用其他函数的函数会导致箭头跳转到其他函数并再次返回。

这也与Python实际执行程序的方式相差不远。希望它和你对Python和常规编程的理解差不多。

## 一个棘手的例子

现在看一个不同的函数。这个用来计算斐波那契数列：
```python
def fibonacci():
    current, next = 0, 1
    while True:
        yield current
        current, next = next, current + next
```

可能你之前见过类似的，或者你已经知道它如何工作以及和其他常见函数的区别。

调用这个函数发生的事情很奇怪，他不返回任何斐波那契数列：
```python
>>> f = fibonacci()
>>> f
<generator object fibonacci at 0x10e737df0>
```

调用该函数返回一个“生成器对象”，想得到斐波那契数列，你必须像这样迭代它：
```python
for n in fibonacci():
    print(n)
```

实际上你可能不想这么做，因为函数没有`return`陈述，这是个死循环。如何让他输出呢，让我们看另一种实现：
```python
>>> f = fibonacci()
>>> print(next(f))
0
>>> print(next(f))
1
>>> print(next(f))
1
>>> print(next(f))
2
```

这个函数很怪。它的奇怪之处在于一个非常具体而且重要的方面。

大部分的Python函数就像上面`fizzbuzz`一样，运行到`return`陈述就结束了（或者运行到函数体结尾，Python隐式的返回`None`）。大部分编程语言中的大部分函数都是这样运行的。但是有些函数，例如上面的`fibonacci()`，它们可以暂停执行并返回一个值，然后稍后在它们停止的地方继续执行。

这种特殊的函数术语上叫做 *协程*，Python生成器就是协程的一种。

具体来说，每当Python在函数体中看到`yield`语句时，它都会将其视为一条指令：在此时暂停该函数的执行，同时返回用`yield`指定的值(也可以只做一个纯`yield`)。然后它会继续运行直到遇到另一个`yield`或者`return`陈述（或者函数体运行结束隐式的返回`None`）。

## 更复杂的协程

虽然看起来所有这些东西的唯一用途是搞一些奇怪的迭代技巧，但一旦你有了协程的概念，你就可以做很多简单的事情，即使是像Python的生成器初始化。

在生成器出现之后，很多额外功能被添加到生成器中。完整的协议是：
* 魔术方法`__next__()`可以被Python内置函数`next()`调用，这用来启动生成器或者恢复暂停的生成器。
* 生成器对象有一个`send()`方法用来把变量传递进暂停的生成器。在生成器内部一般用`yield`右边来进行赋值（例如：`some_variable = yield some _other_variable`），生成器不仅可以向外发送变量还可以捕捉通过`send()`传进来的变量。

* 生成器对象的方法`throw()`允许你发送一个异常并且have it be raised from the generator。

* 生成器对象的方法`close()`允许你关闭生成器，而不是仅仅暂停它。

它为什么如此有用？想象一下一个函数需要读取某个文件的内容。这个过程包括向操作系统发送请求，定向到文件管理系统，找到文件在硬盘中的位置并将其读取到内存中，最后向你的程序发送一个返回信号告知数据已经被准备好。

通常来说你的程序会在这一切发生时卡住一会。在这段时间你的程序被*阻塞*，不能做其他工作，所以我们称之为*阻塞I/0*（“I/O”是“Input/Output”的缩写）。

但是假设我们能写一个函数它发送完把文件载入内存的请求后立刻执行`yield`并暂停。程序这时还可以做其他事，偶尔尝试恢复暂停的程序，如果可以的话还可以`send()`数据到其中。如果它没准备好运行，函数立刻再次`yield`，直到最后它准备好开始工作。

这不是很好吗？

这就是*非阻塞I/O*的理念。你有一大堆读取/写入文件，读取/写入网络套接字的函数，但是当它们等待这些操作完成的时候，它们不会暂停你的整个程序，它们可以暂停它们的执行并在稍后恢复，让你的程序在同时进行其他工作。

这就是异步的一种形式，或者称为异步编程。其中一个原因是，一旦一切函数都能够执行非阻塞I/O，它们就不再完全按照调用的顺序执行了，一些函数可能会暂停并等待来自外部的数据，而另一些则继续执行。

## Everything and the kitchen async

为了让这些完整运作起来，我们需要几个东西。其一是协程，就是可以暂停和恢复它们执行的函数，我们已经通过生成器和`yield`关键字实现了，如果你真的有冒险精神，你可以[使用生成器和其相关方法构建复杂协程](http://dabeaz.com/finalgenerator/)。

不幸的是，这非常繁琐而且没有明显的方法(除非完全检查其代码)来判断某个给定函数是否是协程。

在Python3.4中`asyncio`模块被添加进来，当时这个API被标记为“临时的”（这意味着它不保证向后兼容，预期会不断发展），这个模块为非阻塞/异步I/O操作提供底层工具，还有通过使用`asyncio.coroutine`装饰器将函数显式的标记为协程。

不过这使用起来仍非常麻烦，因为他依旧是围绕生成器协议构建的。因此接下来几个版本添加了一些新的语法和其他特性来支持通常称为`async`/`await`的内容。

基础的理念如下：
* 生成器仍然保留并且仍然是协程，因为它们可以暂停和恢复。
* 新类型的协程被成为“原生协程”，其他异步代码块现在由`async`关键字显式指出。举个例子，取代`def some_function`你现在可以写成`async def some_coroutine`，这样Python就会明白你定义了一个协程。